//using Avro;
using Avro;
using Avro.Generic;
using Confluent.Kafka;
using Confluent.SchemaRegistry;
using Confluent.SchemaRegistry.Serdes;
using Frends.Kafka.Produce.Definitions;
using System;
using System.ComponentModel;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;

namespace Frends.Kafka.Produce;

/// <summary>
/// Kafka Task
/// </summary>
public class Kafka
{
    /// <summary>
    /// Kafka produce operation.
    /// [Documentation](https://tasks.frends.com/tasks/frends-tasks/Frends.Kafka.Produce)
    /// </summary>
    /// <param name="input">Input parameters.</param>
    /// <param name="options">Optional parameters.</param>
    /// <param name="socket">Socket parametes.</param>
    /// <param name="sasl">SASL parameters.</param>
    /// <param name="ssl">SSL parameters.</param>
    /// <param name="schemaRegistry">Schema registry parameters.</param>
    /// <param name="cancellationToken">Token generated by Frends to stop this Task.</param>
    /// <returns>Object { bool Success, string Status, string TopicPartitionOffset, string Timestamp }</returns>
    public static async Task<Result> Produce([PropertyTab] Input input, [PropertyTab] Options options, [PropertyTab] Socket socket, [PropertyTab] Sasl sasl, [PropertyTab] Ssl ssl, [PropertyTab] SchemaRegistry schemaRegistry, CancellationToken cancellationToken)
    {
        try
        {
            var producerConfig = GetProducerConfig(input, options, socket, sasl, ssl);
            if (schemaRegistry.UseSchemaRegistry)
                return await ProduceAvro(input.Topic, input.Key, schemaRegistry, producerConfig, cancellationToken);

            return await ProduceBasic(input.Topic, input.Partition, input.Key, input.Message, producerConfig, cancellationToken);

        }
        catch (KafkaException ke)
        {
            throw new Exception($"Produce KafkaException: {ke}");
        }
        catch (Exception ex)
        {
            throw new Exception($"Produce Exception: {ex}");
        }
    }

    private static async Task<Result> ProduceBasic(string topic, int partition, string msgKey, string msg, ProducerConfig producerConfig, CancellationToken cancellationToken)
    {
        using var producer = new ProducerBuilder<string, string>(producerConfig).Build();

        TopicPartition topicPartition;
        if (partition >= 0)
            topicPartition = new TopicPartition(topic, new Partition(partition));
        else
            topicPartition = new TopicPartition(topic, new Partition());

        Message<string, string> message = new()
        {
            Key = msgKey ?? null,
            Value = msg
        };

        var result = await producer.ProduceAsync(topicPartition, message, cancellationToken);
        return new Result(true, result.Status.ToString(), result.TopicPartitionOffset.ToString(), result.Timestamp.UtcDateTime.ToString());
    }

    private static async Task<Result> ProduceAvro(string topic, string msgKey, SchemaRegistry schemaRegistry, ProducerConfig producerConfig, CancellationToken cancellationToken)
    {
        var schemaRegistryConfig = new SchemaRegistryConfig()
        {
            Url = schemaRegistry.SchemaRegistryUrl,
            BasicAuthCredentialsSource = GetBasicAuthCredentialsSource(schemaRegistry.BasicAuthCredentialsSource),
            EnableSslCertificateVerification = schemaRegistry.EnableSslCertificateVerification,
            BasicAuthUserInfo = schemaRegistry.BasicAuthUserInfo,
            SslCaLocation = schemaRegistry.SslCaLocation,
            RequestTimeoutMs = schemaRegistry.RequestTimeoutMs,
            MaxCachedSchemas = schemaRegistry.MaxCachedSchemas,
            SslKeystorePassword = schemaRegistry.SslKeystorePassword,
            SslKeystoreLocation = schemaRegistry.SslKeystoreLocation,
        };

        using var cachedSchemaRegistryClient = new CachedSchemaRegistryClient(schemaRegistryConfig);
        using var producer = new ProducerBuilder<string, GenericRecord>(producerConfig)
            .SetValueSerializer(new AvroSerializer<GenericRecord>(cachedSchemaRegistryClient))
            .Build();

        GenericRecord record = null;

        foreach (var init in schemaRegistry.Records)
        {
            GenericRecord nestedRecord = null;

            record = new GenericRecord((RecordSchema)Avro.Schema.Parse(!string.IsNullOrEmpty(init.RecordSchemaJsonFile)
                    ? File.ReadAllText(init.RecordSchemaJsonFile)
                    : init.RecordSchemaJson));

            if (init.IsNestedGenericRecord)
            {
                foreach (var nr in init.NestedRecord)
                {
                    nestedRecord = new GenericRecord((RecordSchema)Avro.Schema.Parse(!string.IsNullOrEmpty(nr.RecordSchemaJsonFile)
                    ? File.ReadAllText(nr.RecordSchemaJsonFile)
                    : nr.RecordSchemaJson));

                    nestedRecord.Add(nr.Name, nr.Value);
                }
                record.Add(init.Name, nestedRecord);
            }
            else
                record.Add(init.Name, init.Value);

        }
        var result = await producer.ProduceAsync(topic, new Message<string, GenericRecord> { Key = msgKey, Value = record }, cancellationToken);
        return new Result(true, result.Status.ToString(), result.TopicPartitionOffset.ToString(), result.Timestamp.UtcDateTime.ToString());
    }

    private static ProducerConfig GetProducerConfig(Input input, Options options, Socket socket, Sasl sasl, Ssl ssl)
    {
        ProducerConfig config = new()
        {
            Acks = GetAcks(options.Acks),
            ApiVersionRequest = options.ApiVersionRequest,
            BootstrapServers = input.Host,
            CompressionType = GetCompressionType(input.CompressionType),
            EnableIdempotence = options.EnableIdempotence,
            LingerMs = options.LingerMs,
            MaxInFlight = options.MaxInFlight,
            MessageTimeoutMs = options.MessageTimeoutMs,
            MessageMaxBytes = options.MessageMaxBytes,
            MessageSendMaxRetries = options.MessageSendMaxRetries,
            Partitioner = GetPartitioner(options.Partitioner),
            QueueBufferingMaxKbytes = options.QueueBufferingMaxKbytes,
            QueueBufferingMaxMessages = options.QueueBufferingMaxMessages,
            SecurityProtocol = GetSecurityProtocol(input.SecurityProtocol),
            SocketTimeoutMs = socket.SocketTimeoutMs,
            SocketConnectionSetupTimeoutMs = socket.SocketConnectionSetupTimeoutMs,
            SocketKeepaliveEnable = socket.SocketKeepaliveEnable,
            SocketMaxFails = socket.SocketMaxFails,
            SocketNagleDisable = socket.SocketNagleDisable,
            SocketReceiveBufferBytes = socket.SocketReceiveBufferBytes,
            TransactionalId = options.TransactionalId,
            TransactionTimeoutMs = options.TransactionTimeoutMs,
        };

        if (sasl.UseSasl)
        {
            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
                throw new NotImplementedException("Sasl is implemented only on Linux OS.");
            config.SaslMechanism = GetSaslMechanism(sasl.SaslMechanism);
            config.SaslUsername = sasl.SaslUsername;
            config.SaslPassword = sasl.SaslPassword;
            config.SaslOauthbearerMethod = GetSaslOauthbearerMethod(sasl.SaslOauthbearerMethod);
            config.SaslOauthbearerClientId = string.IsNullOrEmpty(sasl.SaslOauthbearerClientId) ? null : sasl.SaslOauthbearerClientId;
            config.SaslOauthbearerClientSecret = string.IsNullOrEmpty(sasl.SaslOauthbearerClientSecret) ? null : sasl.SaslOauthbearerClientSecret;
            config.SaslOauthbearerTokenEndpointUrl = string.IsNullOrEmpty(sasl.SaslOauthbearerTokenEndpointUrl) ? null : sasl.SaslOauthbearerTokenEndpointUrl;
            config.SaslOauthbearerConfig = string.IsNullOrEmpty(sasl.SaslOauthbearerConfig) ? null : sasl.SaslOauthbearerConfig;
            config.SaslOauthbearerExtensions = string.IsNullOrEmpty(sasl.SaslOauthbearerExtensions) ? null : sasl.SaslOauthbearerExtensions;
            config.SaslOauthbearerScope = string.IsNullOrEmpty(sasl.SaslOauthbearerScope) ? null : sasl.SaslOauthbearerScope;
            config.SaslKerberosKeytab = string.IsNullOrEmpty(sasl.SaslKerberosKeytab) ? null : sasl.SaslKerberosKeytab;
            config.SaslKerberosMinTimeBeforeRelogin = sasl.SaslKerberosMinTimeBeforeRelogin;
            config.SaslKerberosPrincipal = sasl.SaslKerberosPrincipal;
            config.SaslKerberosServiceName = sasl.SaslKerberosServiceName;
        }

        if (ssl.UseSsl)
        {
            config.SslEndpointIdentificationAlgorithm = GetSslEndpointIdentificationAlgorithm(ssl);
            config.EnableSslCertificateVerification = ssl.EnableSslCertificateVerification;
            config.SslCertificateLocation = string.IsNullOrEmpty(ssl.SslCertificateLocation) ? null : ssl.SslCertificateLocation;
            config.SslCertificatePem = string.IsNullOrEmpty(ssl.SslCertificatePem) ? null : ssl.SslCertificatePem;
            if (!string.IsNullOrEmpty(ssl.SslCaCertificateStores))
                config.SslCaCertificateStores = ssl.SslCaCertificateStores;
            config.SslCaLocation = string.IsNullOrEmpty(ssl.SslCaLocation) ? null : ssl.SslCaLocation;
            config.SslCaPem = string.IsNullOrEmpty(ssl.SslCaPem) ? null : ssl.SslCaPem;
            config.SslKeyLocation = string.IsNullOrEmpty(ssl.SslKeyLocation) ? null : ssl.SslKeyLocation;
            config.SslKeyPassword = string.IsNullOrEmpty(ssl.SslKeyPassword) ? null : ssl.SslKeyPassword;
            config.SslKeyPem = string.IsNullOrEmpty(ssl.SslKeyPem) ? null : ssl.SslKeyPem;
            config.SslKeystoreLocation = string.IsNullOrEmpty(ssl.SslKeystoreLocation) ? null : ssl.SslKeystoreLocation;
            config.SslKeystorePassword = string.IsNullOrEmpty(ssl.SslKeystorePassword) ? null : ssl.SslKeystorePassword;
            config.SslEngineLocation = string.IsNullOrEmpty(ssl.SslEngineLocation) ? null : ssl.SslEngineLocation;
            config.SslCipherSuites = string.IsNullOrEmpty(ssl.SslCipherSuites) ? null : ssl.SslCipherSuites;
            config.SslCrlLocation = string.IsNullOrEmpty(ssl.SslCrlLocation) ? null : ssl.SslCrlLocation;
            config.SslCurvesList = string.IsNullOrEmpty(ssl.SslCurvesList) ? null : ssl.SslCurvesList;
            config.SslSigalgsList = string.IsNullOrEmpty(ssl.SslSigalgsList) ? null : ssl.SslSigalgsList;
        }

        return config;
    }

    private static AuthCredentialsSource GetBasicAuthCredentialsSource(AuthCredentialsSources authCredentialsSources)
    {
        return authCredentialsSources switch
        {
            AuthCredentialsSources.UserInfo => AuthCredentialsSource.UserInfo,
            AuthCredentialsSources.SaslInherit => AuthCredentialsSource.SaslInherit,
            _ => throw new ArgumentException($"GetBasicAuthCredentialsSource exception: Value '{authCredentialsSources}' not supported."),
        };
    }

    private static SecurityProtocol GetSecurityProtocol(SecurityProtocols securityProtocols)
    {
        return securityProtocols switch
        {
            SecurityProtocols.Plaintext => SecurityProtocol.Plaintext,
            SecurityProtocols.Ssl => SecurityProtocol.Ssl,
            SecurityProtocols.SaslPlaintext => SecurityProtocol.SaslPlaintext,
            SecurityProtocols.SaslSsl => SecurityProtocol.SaslSsl,
            _ => throw new ArgumentException($"GetSecurityProtocol exception: Value '{securityProtocols}' not supported."),
        };
    }

    private static SslEndpointIdentificationAlgorithm GetSslEndpointIdentificationAlgorithm(SslEndpointIdentificationAlgorithms sslEndpointIdentificationAlgorithms)
    {
        return sslEndpointIdentificationAlgorithms switch
        {
            SslEndpointIdentificationAlgorithms.None => SslEndpointIdentificationAlgorithm.None,
            SslEndpointIdentificationAlgorithms.Https => SslEndpointIdentificationAlgorithm.Https,
            _ => throw new ArgumentException($"GetSslEndpointIdentificationAlgorithm exception: Value '{sslEndpointIdentificationAlgorithms}' not supported."),
        };
    }

    private static CompressionType GetCompressionType(CompressionTypes compressionType)
    {
        return compressionType switch
        {
            CompressionTypes.None => CompressionType.None,
            CompressionTypes.Gzip => CompressionType.Gzip,
            CompressionTypes.Snappy => CompressionType.Snappy,
            CompressionTypes.Lz4 => CompressionType.Lz4,
            CompressionTypes.Zstd => CompressionType.Zstd,
            _ => throw new ArgumentException($"GetCompressionType exception: Value '{compressionType}' not supported."),
        };
    }

    private static Acks GetAcks(Ack ack)
    {
        return ack switch
        {
            Ack.None => Acks.None,
            Ack.Leader => Acks.Leader,
            Ack.All => Acks.All,
            _ => throw new ArgumentException($"GetAcks exception: Value {ack} not supported."),
        };
    }

    private static Partitioner GetPartitioner(Partitioners partitioners)
    {
        return partitioners switch
        {
            Partitioners.Random => Partitioner.Random,
            Partitioners.Consistent => Partitioner.Consistent,
            Partitioners.ConsistentRandom => Partitioner.ConsistentRandom,
            Partitioners.Murmur2 => Partitioner.Murmur2,
            Partitioners.Murmur2Random => Partitioner.Murmur2Random,
            _ => throw new ArgumentException($"GetPartitioner exception: Value '{partitioners}' not supported."),
        };
    }

    private static SaslOauthbearerMethod GetSaslOauthbearerMethod(SaslOauthbearerMethods saslOauthbearerMethods)
    {
        return saslOauthbearerMethods switch
        {
            SaslOauthbearerMethods.Default => SaslOauthbearerMethod.Default,
            SaslOauthbearerMethods.Oidc => SaslOauthbearerMethod.Oidc,
            _ => throw new ArgumentException($"GetSaslOauthbearerMethod exception: Value '{saslOauthbearerMethods}' not supported."),
        };
    }

    private static SaslMechanism GetSaslMechanism(SaslMechanisms saslMechanisms)
    {
        return saslMechanisms switch
        {
            SaslMechanisms.Gssapi => SaslMechanism.Gssapi,
            SaslMechanisms.Plain => SaslMechanism.Plain,
            SaslMechanisms.ScramSha256 => SaslMechanism.ScramSha256,
            SaslMechanisms.ScramSha512 => SaslMechanism.ScramSha512,
            SaslMechanisms.OAuthBearer => SaslMechanism.OAuthBearer,
            _ => throw new ArgumentException($"GetSaslMechanism exception: Value '{saslMechanisms}' not supported."),
        };
    }
}