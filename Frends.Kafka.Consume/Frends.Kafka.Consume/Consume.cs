using Avro.Generic;
using Confluent.Kafka;
using Confluent.Kafka.SyncOverAsync;
using Confluent.SchemaRegistry;
using Confluent.SchemaRegistry.Serdes;
using Frends.Kafka.Consume.Definitions;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;

namespace Frends.Kafka.Consume;

/// <summary>
/// Kafka Task
/// </summary>
public class Kafka
{
    /// <summary>
    /// Kafka Consume operation.
    /// [Documentation](https://tasks.frends.com/tasks/frends-tasks/Frends.Kafka.Consume)
    /// </summary>
    /// <param name="input">Input parameters.</param>
    /// <param name="socket">Socket parametes.</param>
    /// <param name="sasl">SASL parameters.</param>
    /// <param name="ssl">SSL parameters.</param>
    /// <param name="schemaRegistry">SchemaRegistry paramaters.</param>
    /// <param name="options">Optional parameters.</param>
    /// <param name="cancellationToken">Token generated by Frends to stop this task.</param>
    /// <returns>Object { bool Success, List&lt;Message&gt; Messages }</returns>
    public static Result Consume([PropertyTab] Input input, [PropertyTab] Socket socket, [PropertyTab] Sasl sasl, [PropertyTab] Ssl ssl, [PropertyTab] SchemaRegistry schemaRegistry, [PropertyTab] Options options, CancellationToken cancellationToken)
    {
        try
        {
            if (options.MaxPollIntervalMs < options.SessionTimeoutMs)
                throw new Exception("Options.MaxPollIntervalMs must be >= Options.SessionTimeoutMs");

            return schemaRegistry.UseSchemaRegistry
                ? ConsumeAvro(input.Partition, input.Topic, input.MessageCount, input.Timeout, options.EncodeMessageKey, schemaRegistry, Configurations(input, options, socket, sasl, ssl), cancellationToken)
                : ConsumeBasic(input.Partition, input.Topic, input.MessageCount, input.Timeout, options.EncodeMessageKey, Configurations(input, options, socket, sasl, ssl), cancellationToken);

        }
        catch (Exception)
        {

            throw;
        }
    }

    private static Result ConsumeBasic(int partition, string topic, int messageCount, int timeout, bool encodeKey, ConsumerConfig consumerConfig, CancellationToken cancellationToken)
    {
        var result = new List<Message>();
        using var consumer = new ConsumerBuilder<byte[], string>(consumerConfig).Build();

        try
        {
            if (partition >= 0)
            {
                var topicPartition = new TopicPartition(topic, new Partition(partition));
                consumer.Assign(topicPartition);
            }
            else
                consumer.Subscribe(topic);

            while (messageCount == 0 || result.Count < messageCount)
            {
                cancellationToken.ThrowIfCancellationRequested();
                var cr = timeout > 0 ? consumer.Consume(timeout) : consumer.Consume(cancellationToken);
                if (cr != null)
                    result.Add(new Message()
                    {
                        Key = cr.Message.Key != null
                            ? encodeKey ? Encoding.UTF8.GetString(cr.Message.Key) : cr.Message.Key
                            : null,
                        Value = cr.Message.Value ?? null,
                    });
                else
                    break;
            }
        }
        catch (Exception)
        {
            throw;
        }
        finally
        {
            consumer.Close();
            consumer.Dispose();
        }

        return new Result(true, result);
    }



    private static Result ConsumeAvro(int partition, string topic, int messageCount, int timeout, bool encodeKey, SchemaRegistry schemaRegistry, ConsumerConfig consumerConfig, CancellationToken cancellationToken)
    {
        var result = new List<Message>();

        using var cachedSchemaRegistryClient = new CachedSchemaRegistryClient(GetSchemaRegistryConfig(schemaRegistry));
        using var consumer = new ConsumerBuilder<byte[], GenericRecord>(consumerConfig)
            .SetValueDeserializer(new AvroDeserializer<GenericRecord>(cachedSchemaRegistryClient).AsSyncOverAsync())
            .Build();

        try
        {
            if (partition >= 0)
            {
                var topicPartition = new TopicPartition(topic, new Partition(partition));
                consumer.Assign(topicPartition);
            }
            else
                consumer.Subscribe(topic);

            while (messageCount == 0 || result.Count < messageCount)
            {
                cancellationToken.ThrowIfCancellationRequested();
                var cr = timeout > 0 ? consumer.Consume(timeout) : consumer.Consume(cancellationToken);
                if (cr != null)
                    result.Add(new Message()
                    {
                        Key = cr.Message.Key != null
                            ? encodeKey ? Encoding.UTF8.GetString(cr.Message.Key) : cr.Message.Key
                            : null,
                        Value = cr.Message.Value ?? null,
                    });
                else
                    break;
            }
        }
        catch (Exception)
        {
            throw;
        }
        finally
        {
            consumer.Close();
            consumer.Dispose();
        }

        return new Result(true, result);
    }

    private static SchemaRegistryConfig GetSchemaRegistryConfig(SchemaRegistry schemaRegistry)
    {
        var schemaRegistryConfig = new SchemaRegistryConfig()
        {
            Url = schemaRegistry.SchemaRegistryUrl,
            BasicAuthCredentialsSource = GetBasicAuthCredentialsSource(schemaRegistry.BasicAuthCredentialsSource),
            BasicAuthUserInfo = AssignIfNotNullOrEmpty(schemaRegistry.BasicAuthUserInfo, null),
            RequestTimeoutMs = schemaRegistry.RequestTimeoutMs,
            MaxCachedSchemas = schemaRegistry.MaxCachedSchemas,
        };

        if (!string.IsNullOrEmpty(schemaRegistry.SslCaLocation))
            schemaRegistryConfig.SslCaLocation = schemaRegistry.SslCaLocation;
        if (!string.IsNullOrEmpty(schemaRegistry.SslKeystoreLocation))
            schemaRegistryConfig.SslKeystoreLocation = schemaRegistry.SslKeystoreLocation;
        if (!string.IsNullOrEmpty(schemaRegistry.SslKeystorePassword))
            schemaRegistryConfig.SslKeystorePassword = schemaRegistry.SslKeystorePassword;

        return schemaRegistryConfig;
    }
    private static ConsumerConfig Configurations(Input input, Options options, Socket socket, Sasl sasl, Ssl ssl)
    {
        ConsumerConfig config = new()
        {
            Acks = GetAcks(options),
            AutoCommitIntervalMs = options.AutoCommitIntervalMs,
            AutoOffsetReset = GetAutoOffsetReset(options),
            BootstrapServers = input.Host,
            BrokerAddressFamily = GetBrokerAddressFamily(options),
            ConnectionsMaxIdleMs = options.ConnectionsMaxIdleMs,
            CheckCrcs = options.CheckCrcs,
            EnableAutoCommit = options.EnableAutoCommit,
            EnableAutoOffsetStore = options.EnableAutoOffsetStore,
            FetchErrorBackoffMs = options.FetchErrorBackoffMs,
            FetchMaxBytes = options.FetchMaxBytes,
            FetchMinBytes = options.FetchMinBytes,
            FetchWaitMaxMs = options.FetchWaitMaxMs,
            GroupInstanceId = AssignIfNotNullOrEmpty(options.GroupInstanceId, null),
            HeartbeatIntervalMs = options.HeartbeatIntervalMs,
            IsolationLevel = GetIsolationLevel(options),
            MaxPollIntervalMs = options.MaxPollIntervalMs,
            MaxInFlight = options.MaxInFlight,
            MessageMaxBytes = options.MessageMaxBytes,
            QueuedMaxMessagesKbytes = options.QueuedMaxMessagesKbytes,
            QueuedMinMessages = options.QueuedMinMessages,
            ReconnectBackoffMaxMs = options.ReconnectBackoffMaxMs,
            ReconnectBackoffMs = options.ReconnectBackoffMs,
            SecurityProtocol = GetSecurityProtocol(input),
            SocketTimeoutMs = socket.SocketTimeoutMs,
            SocketConnectionSetupTimeoutMs = socket.SocketConnectionSetupTimeoutMs,
            SocketKeepaliveEnable = socket.SocketKeepaliveEnable,
            SocketMaxFails = socket.SocketMaxFails,
            SocketNagleDisable = socket.SocketNagleDisable,
            SocketReceiveBufferBytes = socket.SocketReceiveBufferBytes,
            SessionTimeoutMs = options.SessionTimeoutMs,
        };

        // This IF statement is required because the setter does not like nulls or empty strings in cases where we do not want to assign anything.
        if (!string.IsNullOrEmpty(options.Debug))
            config.Debug = options.Debug;
        if (!string.IsNullOrEmpty(options.GroupId))
            config.GroupId = options.GroupId;

        if (sasl.UseSasl)
        {
            config.SaslMechanism = GetSaslMechanism(sasl);
            config.SaslUsername = sasl.SaslUsername;
            config.SaslPassword = sasl.SaslPassword;
        }

        if (sasl.SaslOauthbearerMethod is SaslOauthbearerMethods.Oidc)
        {
            config.SaslOauthbearerMethod = SaslOauthbearerMethod.Oidc;
            config.SaslOauthbearerClientId = sasl.SaslOauthbearerClientId;
            config.SaslOauthbearerClientSecret = sasl.SaslOauthbearerClientSecret;
            config.SaslOauthbearerTokenEndpointUrl = AssignIfNotNullOrEmpty(sasl.SaslOauthbearerTokenEndpointUrl, null);
            config.SaslOauthbearerConfig = AssignIfNotNullOrEmpty(sasl.SaslOauthbearerConfig, null);
            config.SaslOauthbearerExtensions = AssignIfNotNullOrEmpty(sasl.SaslOauthbearerExtensions, null);
            config.SaslOauthbearerScope = AssignIfNotNullOrEmpty(sasl.SaslOauthbearerScope, null);
        }
        else
            config.SaslOauthbearerMethod = SaslOauthbearerMethod.Default;

        if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            config.SaslKerberosKeytab = AssignIfNotNullOrEmpty(sasl.SaslKerberosKeytab, null);
            config.SaslKerberosMinTimeBeforeRelogin = sasl.SaslKerberosMinTimeBeforeRelogin;
            config.SaslKerberosPrincipal = sasl.SaslKerberosPrincipal;
            config.SaslKerberosServiceName = sasl.SaslKerberosServiceName;
        }

        if (ssl.UseSsl)
        {
            config.SslEndpointIdentificationAlgorithm = GetSslEndpointIdentificationAlgorithm(ssl);
            config.EnableSslCertificateVerification = ssl.EnableSslCertificateVerification;
            config.SslCertificateLocation = AssignIfNotNullOrEmpty(ssl.SslCertificateLocation, null);
            config.SslCertificatePem = string.IsNullOrEmpty(ssl.SslCertificatePem) ? null : ssl.SslCertificatePem;
            if (!string.IsNullOrEmpty(ssl.SslCaCertificateStores))
                config.SslCaCertificateStores = ssl.SslCaCertificateStores;
            config.SslCaLocation = AssignIfNotNullOrEmpty(ssl.SslCaLocation, null);
            config.SslCaPem = AssignIfNotNullOrEmpty(ssl.SslCaPem, null);
            config.SslKeyLocation = AssignIfNotNullOrEmpty(ssl.SslKeyLocation, null);
            config.SslKeyPassword = AssignIfNotNullOrEmpty(ssl.SslKeyPassword, null);
            config.SslKeyPem = AssignIfNotNullOrEmpty(ssl.SslKeyPem, null);
            config.SslKeystoreLocation = AssignIfNotNullOrEmpty(ssl.SslKeystoreLocation, null);
            config.SslKeystorePassword = AssignIfNotNullOrEmpty(ssl.SslKeystorePassword, null);
            config.SslEngineLocation = AssignIfNotNullOrEmpty(ssl.SslEngineLocation, null);
            config.SslCipherSuites = AssignIfNotNullOrEmpty(ssl.SslCipherSuites, null);
            config.SslCrlLocation = AssignIfNotNullOrEmpty(ssl.SslCrlLocation, null);
            config.SslCurvesList = AssignIfNotNullOrEmpty(ssl.SslCurvesList, null);
            config.SslSigalgsList = AssignIfNotNullOrEmpty(ssl.SslSigalgsList, null);
        }

        return config;
    }

    private static string AssignIfNotNullOrEmpty(string source, string defaultValue)
    {
        return !string.IsNullOrEmpty(source) ? source : defaultValue;
    }

    private static AuthCredentialsSource GetBasicAuthCredentialsSource(AuthCredentialsSources authCredentialsSources)
    {
        return authCredentialsSources switch
        {
            AuthCredentialsSources.UserInfo => AuthCredentialsSource.UserInfo,
            AuthCredentialsSources.SaslInherit => AuthCredentialsSource.SaslInherit,
            _ => throw new ArgumentException($"GetBasicAuthCredentialsSource exception: Value '{authCredentialsSources}' not supported."),
        };
    }

    private static SecurityProtocol GetSecurityProtocol(Input input)
    {
        return input.SecurityProtocol switch
        {
            SecurityProtocols.Plaintext => SecurityProtocol.Plaintext,
            SecurityProtocols.Ssl => SecurityProtocol.Ssl,
            SecurityProtocols.SaslPlaintext => SecurityProtocol.SaslPlaintext,
            SecurityProtocols.SaslSsl => SecurityProtocol.SaslSsl,
            _ => throw new Exception("GetSecurityProtocol error: Value not supported."),
        };
    }

    private static IsolationLevel GetIsolationLevel(Options options)
    {
        return options.IsolationLevel switch
        {
            IsolationLevels.ReadUncommitted => IsolationLevel.ReadUncommitted,
            IsolationLevels.ReadCommitted => IsolationLevel.ReadCommitted,
            _ => throw new Exception("GetIsolationLevel error: Value not supported."),
        };
    }

    private static BrokerAddressFamily GetBrokerAddressFamily(Options options)
    {
        return options.BrokerAddressFamily switch
        {
            BrokerAddressFamilys.Any => BrokerAddressFamily.Any,
            BrokerAddressFamilys.V4 => BrokerAddressFamily.V4,
            BrokerAddressFamilys.V6 => BrokerAddressFamily.V6,
            _ => throw new Exception("GetBrokerAddressFamily error: Value not supported."),
        };
    }

    private static AutoOffsetReset GetAutoOffsetReset(Options options)
    {
        return options.AutoOffsetReset switch
        {
            AutoOffsetResets.Latest => AutoOffsetReset.Latest,
            AutoOffsetResets.Earliest => AutoOffsetReset.Earliest,
            AutoOffsetResets.Error => AutoOffsetReset.Error,
            _ => throw new Exception("GetAutoOffsetReset error: Value not supported."),
        };
    }

    private static SslEndpointIdentificationAlgorithm GetSslEndpointIdentificationAlgorithm(Ssl ssl)
    {
        return ssl.SslEndpointIdentificationAlgorithm switch
        {
            SslEndpointIdentificationAlgorithms.None => SslEndpointIdentificationAlgorithm.None,
            SslEndpointIdentificationAlgorithms.Https => SslEndpointIdentificationAlgorithm.Https,
            _ => throw new Exception("SslEndpointIdentificationAlgorithm error: Value not supported."),
        };
    }

    private static Acks GetAcks(Options options)
    {
        return options.Acks switch
        {
            Ack.None => Acks.None,
            Ack.Leader => Acks.Leader,
            Ack.All => Acks.All,
            _ => throw new Exception("GetAcks error: Value not supported."),
        };
    }

    private static SaslOauthbearerMethod GetSaslOauthbearerMethod(SaslOauthbearerMethods saslOauthbearerMethod)
    {
        return saslOauthbearerMethod switch
        {
            SaslOauthbearerMethods.Default => SaslOauthbearerMethod.Default,
            SaslOauthbearerMethods.Oidc => SaslOauthbearerMethod.Oidc,
            _ => throw new Exception("GetSaslOauthbearerMethod error: GetSaslOauthbearerMethod not supported."),
        };
    }

    private static SaslMechanism GetSaslMechanism(Sasl sasl)
    {
        return sasl.SaslMechanism switch
        {
            SaslMechanisms.Gssapi => SaslMechanism.Gssapi,
            SaslMechanisms.Plain => SaslMechanism.Plain,
            SaslMechanisms.ScramSha256 => SaslMechanism.ScramSha256,
            SaslMechanisms.ScramSha512 => SaslMechanism.ScramSha512,
            SaslMechanisms.OAuthBearer => SaslMechanism.OAuthBearer,
            _ => throw new Exception("GetSaslMechanism error: SaslMechanisms not supported."),
        };
    }
}